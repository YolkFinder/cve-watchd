package main

import (
	"encoding/json"
	"fmt"
	"github.com/boltdb/bolt"
	"github.com/gorilla/mux"
	"github.com/mmcdole/gofeed"
	"log"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"time"
)

// Configuration represents the configuration structure
type Configuration struct {
	Port            int    `json:"port"`
	BoltDBPath      string `json:"boltdb_path"`
	DatabaseTimeout int    `json:"database_timeout"`
}

// ConfigurationPath is the configuration file path
const ConfigurationPath = "./config.json"

// config holds the daemon configuration
var config *Configuration

// db holds the database instance
var db *bolt.DB

// ArticlesBucket is the bolt db bucket for articles
var ArticlesBucket = []byte("articles")

// Route represents a router route
type Route struct {
	Name        string
	Method      string
	Pattern     string
	HandlerFunc http.HandlerFunc
}

// Routes is a collection of router routes
type Routes []Route

// Logger middleware logs incoming http requests
func Logger(inner http.Handler, name string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		inner.ServeHTTP(w, r)

		log.Printf(
			"%s\t%s\t%s\t%s",
			r.Method,
			r.RequestURI,
			name,
			time.Since(start),
		)
	})
}

// NewRouter creates a new mux router and returns it
func NewRouter() *mux.Router {
	router := mux.NewRouter().StrictSlash(true)
	for _, route := range routes {
		var handler http.Handler
		handler = route.HandlerFunc
		handler = Logger(handler, route.Name)

		router.
			Methods(route.Method).
			Path(route.Pattern).
			Name(route.Name).
			Handler(handler)
	}

	return router
}

// Index is the index handler function
func Index(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Welcome to the News Aggregator API!")
}

// ArticleList is the article list handler function
func ArticleList(w http.ResponseWriter, r *http.Request) {
	var articles []string
	err := db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket(ArticlesBucket)
		if b == nil {
			return fmt.Errorf("Bucket %q not found", ArticlesBucket)
		}

		err := b.ForEach(func(k, v []byte) error {
			articles = append(articles, string(v))
			return nil
		})
		return err
	})
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Error occurred while fetching articles: ", err.Error())
		return
	}
	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintln(w, `{"articles": [`)
	for i, a := range articles {
		fmt.Fprintln(w, a)
		if i != len(articles)-1 {
			fmt.Fprintln(w, ",")
		}
	}
	fmt.Fprintln(w, `]}`)
}

// ArticleCreate is the article create handler function
func ArticleCreate(w http.ResponseWriter, r *http.Request) {
	feedURL := r.FormValue("url")
	if feedURL == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "The url parameter is required.")
		return
	}
	fp := gofeed.NewParser()
	feed, err := fp.ParseURL(feedURL)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "

type Server struct {
	Router       *mux.Router
	Feeds        []string
	FeedData     map[string]*FeedData
	Store        *bolt.DB
	DBPath       string
	Port         string
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
	MaxFeedLimit int
}

type FeedData struct {
	Feed     *gofeed.Feed
	LastETag string
	LastMod  string
}

type Config struct {
	Feeds        []string `json:"feeds"`
	Port         string   `json:"port"`
	ReadTimeout  string   `json:"read_timeout"`
	WriteTimeout string   `json:"write_timeout"`
	DBPath       string   `json:"db_path"`
	MaxFeedLimit int      `json:"max_feed_limit"`
}

func (s *Server) Run() error {
	var err error

	// Init router
	s.Router = mux.NewRouter()

	// Init feeds
	s.FeedData = make(map[string]*FeedData)
	for _, feed := range s.Feeds {
		s.FeedData[feed] = &FeedData{}
	}

	// Init store
	s.Store, err = bolt.Open(s.DBPath, 0600, &bolt.Options{Timeout: 1 * time.Second})
	if err != nil {
		return fmt.Errorf("failed to open boltdb: %s", err)
	}

	// Create buckets
	err = s.Store.Update(func(tx *bolt.Tx) error {
		_, err = tx.CreateBucketIfNotExists([]byte("feeds"))
		if err != nil {
			return fmt.Errorf("failed to create feeds bucket: %s", err)
		}
		_, err = tx.CreateBucketIfNotExists([]byte("feed_data"))
		if err != nil {
			return fmt.Errorf("failed to create feed_data bucket: %s", err)
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("failed to create buckets: %s", err)
	}

	// Init routes
	s.initRoutes()

	// Start server
	srv := &http.Server{
		Handler:      s.Router,
		Addr:         ":" + s.Port,
		ReadTimeout:  s.ReadTimeout,
		WriteTimeout: s.WriteTimeout,
	}
	fmt.Printf("Starting server on %s...\n", s.Port)
	if err := srv.ListenAndServe(); err != nil {
		return fmt.Errorf("server error: %s", err)
	}
	return nil
}

